Reflection
Designing the domain model and class diagram for the University Clinic GBV Tracker project presented several challenges. One of the primary challenges was identifying the key entities and defining their attributes and methods. The process required a deep understanding of the system's requirements and use cases, as well as careful consideration of how each entity interacts with others.

Challenges in Abstraction: Abstraction was a significant challenge, particularly in determining the level of detail to include for each entity. Striking a balance between simplicity and comprehensiveness was crucial. Including too many attributes and methods could complicate the model, while too few might overlook important aspects of the system. For example, defining the attributes and methods for the GBVCase entity required careful consideration of what information is essential for tracking and managing cases effectively.

Challenges in Defining Relationships: Defining relationships between entities was another challenge. The system involves various interactions between users, clinic staff, and administrators, each with specific roles and responsibilities. Accurately representing these relationships in the class diagram required a clear understanding of how entities interact in real-world scenarios. For instance, the relationship between UserAccount and GBVCase needed to reflect that users can report cases, while clinic staff manage them. Ensuring that these relationships were accurately represented in the diagram was crucial for maintaining the integrity of the system's design.

Challenges in Method Definitions: Defining methods for each entity posed challenges in ensuring that they align with the system's functionality. Each method needed to be relevant to the entity's role and responsibilities. For example, the methods for the UserAccount entity, such as activateAccount() and suspendAccount(), needed to reflect the actions users can perform on their accounts. Ensuring that these methods were comprehensive and accurately represented the system's functionality was essential for creating a robust domain model.

Alignment with Previous Assignments: The class diagram aligns with previous assignments by incorporating the requirements, use cases, and state/activity diagrams. The entities and relationships defined in the domain model reflect the functional requirements identified in Assignment 4. The use cases from Assignment 5 provided a basis for defining the methods and interactions between entities. The state and activity diagrams from Assignment 8 helped in understanding the dynamic behavior of the system, which was crucial for defining the transitions and workflows in the class diagram.

Trade-offs Made: Several trade-offs were made during the design process. One significant trade-off was simplifying inheritance in favor of composition. While inheritance can provide a clear hierarchical structure, it can also complicate the model and make it less flexible. By using composition, we were able to create a more modular and adaptable design. Another trade-off was balancing the level of detail in the domain model. Including too many details could make the model cumbersome, while too few could overlook important aspects. Striking the right balance was essential for creating a comprehensive yet manageable model.

Lessons Learned: The process of designing the domain model and class diagram provided valuable insights into object-oriented design. One key lesson learned was the importance of understanding the system's requirements and use cases. A thorough understanding of these aspects is crucial for identifying the key entities and defining their attributes and methods. Another lesson was the significance of accurately representing relationships between entities. These relationships are essential for maintaining the integrity of the system's design and ensuring that it functions as intended.

Additionally, the process highlighted the importance of abstraction in managing complexity. By focusing on the essential attributes and methods for each entity, we were able to create a model that is both comprehensive and manageable. The use of UML and Mermaid.js provided a clear and visual representation of the system's structure, making it easier to understand and communicate the design.
